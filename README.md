[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18391158&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

 Software Engineering is the application of engineering principles, methods and tools to create high quality software.It enables building solutions that meet user requirements,automate tasks and solve problems.

Identify and describe at least three key milestones in the evolution of software engineering.

Innovation of Computers in 1940-1950 provided a challenge for people to solve mathematical problems and build solutions. This created a foundation for Software Engineering.Then Programming languages were discovered by different personalities. This ranged from low-level languages to current high-level programming languages. The use of Computers was slowly adopted making people to become more and more innovative to find solutions.

List and briefly explain the phases of the Software Development Life Cycle.

- Ideation stage: An idea is born and is evaluated. This involves researching about the domain and the idea and examining the viability
- Requirements Analysis: This involves gathering and documenting requirements for the solution to be developed.
- Design: This involves creating high-level designs to map the solution architecture. This is where UML is applied to help design components of the software.
- Implementation: This is the coding stage where the engineers code the solution according to the specifications in earlier stages.
- Testing: This is one of the most crucial part.The solution undergoes different types of testing to make sure the solution meets satndard quality.
- Deployment: The Software is made available by deploying to the code
- Maintenance: This involves an iterative process of support, making updates and make sure the software works well.
  
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
 **Comparison of Waterfall and Agile Methodologies**

| Feature          | **Waterfall Methodology**                           | **Agile Methodology**                         |
|-----------------|-------------------------------------------------|-----------------------------------------------|
| **Approach**    | Sequential, linear process                        | Iterative, flexible, and incremental process |
| **Phases**      | Requirements → Design → Implementation → Testing → Deployment → Maintenance | Continuous cycles of planning, development, testing, and feedback |
| **Flexibility** | Rigid, changes are difficult once a phase is completed | Highly adaptable, allows continuous improvements |
| **Customer Involvement** | Limited; customer feedback is mainly at the start and end | High; frequent collaboration with stakeholders |
| **Delivery**    | Delivered as a complete product at the end | Delivered in smaller, usable increments |
| **Best For**    | Well-defined projects with stable requirements | Projects with evolving requirements |
| **Risk Management** | High risk if requirements are incorrect | Lower risk as issues are addressed early |
| **Examples of Use Cases** | Infrastructure projects, hardware development, government projects | Software development, startups, dynamic web applications |

---

**When to Use Waterfall** 

Example 1: Building a Bridge  
- Requirements are **fixed** and well-documented.  
- Each phase (design, construction, testing) must be **completed sequentially** before moving to the next.  
- Changes after implementation are **costly and time-consuming**.  

Example 2: Developing a Banking System  
- Financial applications require **strict compliance** and **detailed planning** before development.  
- Security and regulatory constraints make iterative changes **difficult**.  

---

**When to Use Agile**  
Example 1: Developing a Mobile App  
- Customer needs may **change frequently**, requiring adaptability.  
- Allows for **continuous feedback** and feature updates based on user input.  

Example 2: Startup Software Development  
- Startups often launch a **Minimum Viable Product (MVP)** first, then iterate based on user feedback.  
- Agile enables **rapid changes** and quick adaptation to market needs.  

---

**Conclusion**
 
- **Waterfall is ideal** for projects with **fixed requirements** and **predictable outcomes**.  
- **Agile is better** for projects needing **flexibility**, **continuous feedback**, and **incremental development**.  


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

- Software Developer: Responsible for writing quality code to implement the Software.
- Quality Assurance Engineer: Is responsible for making sure the code meets a certain set of standards.
- Project manager: Does overall monitoring of planning, execution and delivery of items in time.
  
Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
- IDE helps to provide an environment for editing code and developing software e.g, Microsoft Visual Studio, while VCS is important for keeping track of different versions of of the softare e.g git

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
- Strict timelines: This can be overcome by proper planning of delivery
- Change of requirements: Build software that is easily maintainable and adaptable. Make sure the requirements are properly analysed in the initial stages.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit Testing: Testing individual components
2. Integration testing: Testing whether different components can interact seamlessly
3. System testing: Holistic testing of the entire system
4. Acceptance testing: checking if the software meets the requiremnts and user specifications


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

- Prompt engineering is the process of crafting effective and precise instructions (prompts) to optimize the performance of AI models, such as ChatGPT. It plays a crucial role in ensuring that the model generates accurate, relevant, and contextually appropriate responses. Well-structured prompts improve the efficiency and reliability of AI-driven interactions in various applications, including customer support, content creation, and data analysis.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

 **Example of a Vague vs. Improved Prompt**

**Vague Prompt:**
> "Tell me about history."

**Improved Prompt:**
> "Provide a brief overview of World War II, including its causes, major events, and outcomes. Keep the response within 200 words."

By refining prompts, users can maximize the effectiveness of AI interactions, ensuring meaningful and high-quality outputs.

